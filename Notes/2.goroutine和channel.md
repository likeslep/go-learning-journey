1. 一个channel，当它没有关闭且没有数据时，接收方会一直阻塞等待发送发往里发送数据；当channel关闭后，发送方不能再给channel发送数据，接收方在读完最后一个数据后，所有后续的接收操作仍然顺畅进行，只是获取到的是零值。没有一个直接的方式来判断channel是否关闭，但是这里有一个接收操作的变种，接收操作会产生两个结果，一个通道元素，另一个是布尔值。`v, ok := <- channel`，当`ok`的值为true代表接收成功，false表示当前的接收操作在一个关闭后的通道上。当然上边的方法看起来比较笨拙，所以在循环接收操作时go语言为我们提供了range循环语法，当接收完最后一个值后关闭循环。
2. 通道的关闭不是必须的，只有在通知接收方 goroutine 所有的数据都发送完毕时才需要去关闭通道。通道是可以通过垃圾回收器来回收的，垃圾回收器会判断通道是否可以访问来决定是否回收它，而不是根据它是否关闭。**试图关闭一个已经关闭的通道会导致宕机！**
3. **单向通道类型：**`chan <- int   //表示通道只能发送`  `<- chan int   //表示通道只能接收`。通道的关闭只能有发送方来做，也就是说当关闭一个只允许接收的通道时会在编译阶段发生错误。在调用通道时，函数会根据情况将`chan int`隐式转换为`<- chan int`或`chan <- int`，但是反过来是不被允许的。
4. **goroutine泄露：**就是go程序中创建的goroutine无法按预期结束，持续占用系统资源，最终导致程序性能下降或崩溃。简单来说就是启动了但永远不会结束的gouroutine。goroutine泄露主要发生在长期运行的服务器中，因为当主协程停止时，其它的协程也会被迫停止。


