# Error 
go中的`error`就是一个普通的接口。
```go
type error interface {
    Error() string 
}
```
在基础库中有大量的自定义的error。
```go
http://golang.org/src/pkg/bufio/bufio.go

var (
    ErrInvalidUnreadByte = errors.New("bufio: invalid use of UnreadByte")
    ErrInvalidUnreadRune = errors.New("bufio: invalid use of UnreadRune")
    ErrBufferFull = errors.New("bufio: buffer full")
    ErrNegativeCount = errors.New("bufio:negative count")
)
```
养成好习惯，在创建error时，带上包名，方便我们找问题。

```go 
func New(text string) error {
    return &errorString{text}
}
```
errors.New()返回的是errorString对象的指针。

## Sentinel Error
预定义的特定错误，也就是使用特定的值来表示错误。例如`if err == ErrSOmething{...}`，类似的`io.EOF`，更底层的`syscall.ENOENT`。

**使用预定义的特定错误是最不灵活的错误处理方式，因为调用者必须使用`==`将结果与预先声明的值进行比较。当你想提供更多的上下文时，就会出现一个问题，返回一个不同的错误将破坏相等性问题。甚至是一些有意义的`fmt.Errorf`携带一些上下文，也会破坏调用者`==`，调用者将被迫查看`error.Error()`方法的输出，以查看它是否与特定的字符串匹配。**

使用 Sentinel Error 的场景： 
- 不依赖检查 `error.Error` 的输出。
- Sentinel errors 成为你 API 公共部分。
>如果你的公共函数或方法返回一个特定值的错误，那么该值必须是公开的，当然要有文档记录，这回增加API的表面积。如果API定义了一个返回特定错误的interface，则该接口的所有实现都将被限制为仅返回该错误，即使它们可以提供更具描述性的错误。
- Sentinel errors 在两个包之间创建依赖。
>sentinel errors 最糟糕的问题是它们在两个包之间创建了源代码依赖关系。例如，检查错误是否等于io.EOF，你的代码必须导入io包。这个特定的例子听起来并不那么糟糕，因为它非常常见，但是当项目中的许多包导出错误值时，存在耦合，项目中的其它包必须导入这些错误值才能检查特定的错误条件。

 **结论：尽可能避免 Sentinel Error。**

## Error types
Error type是实现了error接口的自定义类型。例如 MyError 类型记录了文件和行号以展示发生了什么。
```go 
type MyError struct {
    Msg string 
    File string 
    Line int 
}

func (e *MyError) Error() string {
    return fmt.Sprintf("%s:%s:%s", e.File, e.Line, e.Msg)
}

func test() error {
    return &MyError{"Something happened", "server.go", 42}
}
```
因为MyError是一个type，调用者可以使用断言转换成这个类型，来获取更多的上下文信息。
```go
func main() {
    err := test()
    switch err := err.(type) {
        case nil :
            // call suceeded, nothing to do 
        case *MyError:
            fmt.PRintln("error occurred on line: ", err.Line)
        default:
            // unknow error
    }
}
```
与错误值相比，错误类型的一大改进是它们能够包装底层错误以提供更多上下文。一个不错的例子就是`os.PathError`它提供了底层执行什么操作、哪个路径出了什么问题。
```go
type PathError struct {
    Op string 
    Path string 
    Err error
}

func (e *PathError) Error() string 
```

调用者使用类型断言和类型switch，就要让自定义的error变为public。这种模型会导致和调用者产生强耦合，从而导致API变得脆弱。
结论就是尽量避免使用error types，虽然错误类型比sentinel errors更好，因为它可以捕获更多的上下文，但是 error types共享error values许多相同的问题。因此尽量避免错误类型，或者至少避免将它们作为公共API的一部分。

## Opaque errors
这是最灵活的错误处理策略，因为它要求代码和调用者之间的耦合最少。将这种风格称为不透明的错误处理，因为虽然我们知道发生了错误，但没有能力看到错误的内部。作为调用者，关于操作的结果，我们所知道的就是它起作用了，或者没有起作用（成功还是失败）。
这就是不透明错误处理的全部功能——只需要返回错误而不假设其内容。
```go
func fn() error {
    x, err := bar.Foo()
    if err != nil {
        return err 
    }
}
```
在少数情况下，这种二分法错误处理方法是不够的。例如，与进程外的世界进行交互（如网络活动），需要调用方调查错误的性质，以确定重试该操作是否合理。这种情况下，我们可以断言错误实现了特定的行为，而不是断言错误是特定的类型或值。
```go
type temporary interface {
    Temporary() bool 
}

func IsTemporary(err error) bool {
    te, ok := err.(temporary)
    return ok && te.Temporary()
}
```

```go
type errWriter struct {
    Writer io.Writer
    err error 
}

func (e *errWriter) Write(buf []byte) (int, error) {
    if e.err != nil {
        return 0, e.err
    }

    var n int 
    n, e.err = e.Writer.Write(buf)
    return n, nil 
}
```
```go
func WriteResponse(w io.Writer, st Status, headers []Header, body io.Reader) error {
    ew := &errWriter{Writer: w}
    fmt.Fprintf(ew, "HTTP/1.1 %d %s\r\n", st.Code, st.Reason)

    for _, h := range headers {
        fmt.Fprintf(ew, "%s: %s\r\n", h.Key, h.Value)
    }

    fmt.Fprint(ew, "\r\n")
    io.Copy(ew, body)

    return ew.err 
}
```

日志记录与错误无关且对调试没有帮助的信息应被视为噪音，应予以质疑。记录日志应该是因为某些东西失败了，而且日志包含了答案。一些是一些需要记录日志的场景：
- 错误要被日志记录。
- 应用程序处理错误，保证100%完整性。
- 之后不再报告当前错误。

## Wrap errors
`github.com/pkg/errors`
```go
func ReadFile(path string) ([]byte, error) {
    f, err := os.Open(path)
    if err != nil {
        return nil, errors.Wrap(err, "open failed")
    }
    defer f.Close() 

    func main() {
        _, err := ReadConfig()
        if err != nil {
            fmt.Printf("original error: %T %v\n", errors.Cause(err), errors.Cause(err))
            fmt.Printf("stack trace: \n%+v\n", err)
            os.Exit(1)
        }
    }

    func ReadConfig() ([]byte, error) {
        home := os.Getenv("HOME")
        config, err := ReadFile(filepath.Join(home, ".setings.xml"))
        return config, errors.WithMessage(err, "could not read config")
    }

    func main() {
        _, err := ReadConfig()
        if err != nil {
            fmt.Println(err)
            os.Exit(1)
        }
    }
}
```
通过使用 `pkg/errors` 包，可以向错误值添加上下文，这种方式既可以由人也可以由机器检查。
```go 
func Write(w io.Write, buf []byte) errors {
    _, err := w.Write(buf)
    return errors.Wrap(err, "write failed")
}
```

- 如果和其它库进行协作，考虑使用 `errors.Wrap` 或者 `errors.Wrapf` 保存堆栈信息。同样适用于和标准库协作的时候。
  ```go
  f, err := os.Open(path)
  if err != nil {
    return errors.Wrap(err, "failed to open %q", path)
  }
  ```
- 直接返回错误，而不是每个错误产生的地方到处打日志。
- 在程序的顶部或者是工作的 goroutine 顶部（请求入口），使用 `%+v` 把堆栈详情记录起来。
  ```go
  func main() {
    err := app.Run()
    if err != nil {
        fmt.Printf("FATAL: %+v\n", err)
        os.Exit(1)
    }
  }
  ```
- 使用 `errors.Cause` 来获取 root error，再进行和 sentinel error 判定。
- 选择 wrap error 是只有 applications 可以选择应用的策略。具有最高可重用性的包只能返回根错误值。此机制与 Go 标准库中使用的相同（kit库的 sql.ErrNoRows）。
- 这是关于函数 / 方法调用返回的每个错误的基本问题。如果函数 / 方法不打算处理错误，那么用足够的上下文 wrap errors 并将其返回到调用堆栈中。例如，额外的上下文可以是使用的输入参数或失败的查询语句。确定你记录的上下文是足够多还是太多的一个好方法就是检查日志并验证它们在开发期间是否为你工作。
- 一旦确定函数 / 方法将处理错误，错误就不再是错误。如果函数 / 方法仍然需要发出返回，则它不能返回错误值。它应该只返回零（比如降级处理中，你返回了降级数据，然后需要 return nil）。

## Unwrap
go1.13为 errors 和 fmt 标准库包引入了新的特性，以简化处理包含其它错误的错误。其中最重要的是：包含另一个错误的error可以实现返回底层错误的 Unwrap 方法。如果e1.Unwrap()返回e2，那么我们说e1包装了e2，我们可以展开e1获得e2.
go1.13 errors 包包含两个用于检查错误的新函数：Is 和 As。
```go
// if err == ErrNotFound{...}
if errors.Is(err, ErrNotFound) {
    // something wasn't found
}

// if e, ok := err.(*QueryError); ok {...}
if errors.As(err, &e) {
    // err is a *QueryError, and e is set to the error's value
}
```

使用fmt.Errorf向错误添加附加信息。
```go
if err != nil {
    return fmt.Errorf("decompress %v: %v", name, err)
}
```
在go 1.13中fmt.Errorf支持新的`%w`谓词。
```go
if err != nil {
    // Return an error which unwraps to err.
    return fmt.Errorf("decompress %v: %w", name, err)
}
```
用`%w`包装错误可用于errors.Is以及errors.As，通过这种方式可获得更多的上下文，就可以获得更多的信息。

## 作业
>我们在数据库操作的时候，比如dao层中遇到一个sql.ErrNoRows的时候，是否因该wrap这个error，抛给上层。为什么，应该怎么做请写出代码？

**不因该简单地将sql.ErrNoRows wrap后直接抛给上层。**

1. 语义层泄露
   - sql.ErrNoRows 是数据库层的具体错误。
   - 上层（如Service层）不应该关心底层是SQL还是NoSQL。
   - 业务层应该处理业务语义，而非技术细节。
2. 业务含义不同
   - 数据库中没找到记录 != 业务上的“错误”。
   - 可能是正常情况（如查询不存在的用户）。
   - 直接抛出会使Service层难以区分“正常未找到”还是“真正错误”。
3. 破坏封装
   - 暴露了数据存储的具体实现。
   - 如果将来更换数据库（如MySQL——>MongoDB），所有上层代码都要改。

推荐做法：将数据层错误转换为业务层错误

1. 转换为特定错误
```go
var ErrRecordNotFound = errors.New("record not found")

type User struct {
    ID int64
    Name string 
}

type UserDAO struct {
    db *sql.DB
}

func (dao *UserDAO) GetUserByID(id int64) (*User, error) {
    var user User
    err := dao.db.QueryRow("SELECT id, name FROM users WHERE id = ?", id).Scan(&user.ID, &user.Name)

    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            // 将技术错误转化为业务错误
            return nil, ErrRecordNotFound
        }
        // 其它数据库错误，wrap并添加上下文
        return nil, errors.Wrapf(err, "failed to get user by id: %d", id)
    }
    return &user, nil 
}
```

2. 返回零值和nil（简单查询场景）
```go
func (dao *UserDAO) GetUserName(id int64) (string, error) {
    var name string 
    err := dao.db.QueryRow("SELECT id, name FROM users WHERE id = ?", id).Scan(&name)

    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return "", nil // 返回零值，表示没找到
        }
        return "", errors.Wrapf(err, "failed to get name by id: %d", id)
    }
    return &name, nil 
}
```

3. 自定义错误类型（复杂场景）
```go
type ErrorType int 

const (
    NotFound ErrorType = iota
    Conflict 
    InvalidInput
    Internal
)

type BusinessError struct {
    Type ErrorType 
    Message string 
    Err error
}

func (e *BusinessError) Error() string {
    if e.Err != nil {
        return fmt.Sprintf("%s: %v", e.Message, e.Err)
    }
    return e.Message 
}

func NewNotFoundError(msg string, err error) error {
    return &BusinessError {
        Type : NotFound,
        Message : msg,
        Err : err,
    }
}

// 在dao层中使用
func (dao *UserDAO) GetUserByID(id int64) (*User, error) {
    var user User 
    err := dao.db.QueryRow("SELECT id, name FORM users WHERE id = ?", id).Scan(&user.ID, &user.Name)

    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, NewNotFoundError("user not found", err)
        }
        return nil, errors.Wrap(err, "database query failed")
    }
    return &user, nil 
}
```
Service层使用示例
```go
package service

import (
    "your-project/dao"
    "github.com/pkg/errors"
)

type UserService struct {
    userDAO *dao.UserDAO
}

func (s *UserService) GetUserProfile(id int64) (*UserProfile, error) {
    user, err := s.userDAO.GetUserByID(id)
    if err != nil {
        if errors.Is(err, dao.ErrRecordNotFound) {
            // 业务层决定如何处理"未找到"
            return nil, nil // 或返回特定错误
        }
        // 真正的错误，添加业务上下文后向上传递
        return nil, errors.Wrap(err, "failed to get user profile")
    }
    
    // 处理业务逻辑
    return &UserProfile{
        ID:   user.ID,
        Name: user.Name,
    }, nil
}

func (s *UserService) MustGetUser(id int64) (*UserProfile, error) {
    user, err := s.userDAO.GetUserByID(id)
    if err != nil {
        if errors.Is(err, dao.ErrRecordNotFound) {
            // 在某些场景下，找不到用户就是错误
            return nil, errors.New("user must exist but not found")
        }
        return nil, errors.Wrap(err, "failed to get required user")
    }
    
    return convertToProfile(user), nil
}
```
总结：
1. DAO层：
   - `sql.ErrNoRows` ——> `ErrRecordNotFound`（或类似业务错误）
   - 其它数据库错误——>wrap后向上抛
2. Service层：
   - 检查是否为`ErrRecordNotFound`
   - 根据业务逻辑决定：是正常情况还是错误
   - 真正错误添加业务上下文后继续向上
3. 最佳实践：
   - 使用 `errors.Is()` 进行错误比较
   - 使用 `errors.Wrap()` 添加上下文
   - 避免多次wrap同一错误
   - 在应用边界（如HTTP handler）记录错误日志

