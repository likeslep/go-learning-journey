# Golang网络编程
Go语言拥有非常强大的网络编程库，支持各种协议和网络通信方式。一下是一些常见的网络编程库：
1. `net/http`：用于构建http服务器和客户端，支持处理常见的HTTP请求和响应。
2. `net`：提供基本的网络编程功能，支持处理常见的HTTP请求和响应。
3. `net/rpc`：提供了用于实现远程过程调用的API。
4. `net/url`：提供了解析和生成URL的功能，包括查询参数、路径等。
5. `encoding/json`：提供了将json数据转换为go语言对象以及将go语言对象转化为json数据的功能，非常适合与HTTP协议一起使用。
6. `crypto/tls`：提供了用于安全通信的TLS/SSL协议支持。
7. `websocket`：提供了实现websocket协议的支持，用于实现双向通信的web应用程序。

## golang socket编程
```go
package main

import (
    "fmt"
    "net"
)

func main() {
    // 建立一个TCP连接，连接到远程主机的80端口
    conn, err := net.Dial("tcp", "example.com:80")
    if err != nil {
        fmt.Println("Error connecting:", err)
        return
    }

    // 发送一个HTTP GET请求
    fmt.Fprintf(conn, "GET / HTTP/1.0\\r\\n\\r\\n")

    // 从连接中读取服务器的响应
    buf := make([]byte, 1024)
    for {
        n, err := conn.Read(buf)
        if n == 0 || err != nil {
            break
        }
        fmt.Print(string(buf[0:n]))
    }
}
```
上面代码使用net包中的Dial函数与远程主机的80端口建立连接。然后，使用fmt包中的Fprintf函数向连接中写入一个HTTP GET请求。最后，通过使用Read函数读取并打印服务器的响应。

出了上述示例外，Go语言的标准库还提供了很多其它的网络编程工具和函数，例如：
- `netListen`：用于监听一个网络地址，并返回一个net.Listener对象，可以用来接受连接请求。
- `net.Accept`：用于接受一个连接请求，并返回一个net.Conn对象，可以用来进行数据通信。
- `net.DialTimeout`：类似于net.Dial，但是可以设置一个连接超时时间。
- `net.ResolveTCPAddr`：用于解析TCP网络地址，返回一个TCP地址对象。

## Golang TCP编程
1. `net.Listen("tcp", address string) (Listen, error)`：创建一个TCP服务器，监听指定地址。
2. `Listener.Accept() (Conn, error)`：接受一个客户端连接请求，返回一个Conn对象和一个错误。
3. `net.ResolveTCPAddr(network, address string) (*TCPAddr, error)`：解析一个TCP地址，返回一个`TCPAddr`对象和一个错误。
4. `TCPConn.SetReadDeadline(t time.Time) error`和`TCPConn.SetWriteDeadline(t time.Time) error`：设置读取或写入超时时间，超时后会返回一个`net.Error`类型的错误。

## golang 实现一个tcp聊天室
```go
package main

import (
	"fmt"
	"net"
)

var (
	clients    = make(map[net.Addr]net.Conn)
	addCh      = make(chan net.Conn)
	delCh      = make(chan net.Addr)
	messageCh  = make(chan []byte)
	listenAddr = "localhost:8080"
)

func main() {
	fmt.Println("Server started on", listenAddr)
	listener, err := net.Listen("tcp", listenAddr)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer listener.Close()

	go broadcaster()

	for {
		conn, err := listener.Accept()
		if err != nil {
			fmt.Println(err)
			continue
		}

		addCh <- conn

		go handleConn(conn)
	}
}

func broadcaster() {
	for {
		select {
		case conn := <-addCh:
			clients[conn.RemoteAddr()] = conn
			fmt.Println("New client:", conn.RemoteAddr())
		case addr := <-delCh:
			delete(clients, addr)
			fmt.Println("Client disconnected:", addr)
		case msg := <-messageCh:
			for _, conn := range clients {
				_, err := conn.Write(msg)
				if err != nil {
					fmt.Println(err)
				}
			}
		}
	}
}

func handleConn(conn net.Conn) {
	defer func() {
		delCh <- conn.RemoteAddr()
		conn.Close()
	}()

	for {
		msg := make([]byte, 4096)
		n, err := conn.Read(msg)
		if err != nil {
			return
		}

		messageCh <- msg[:n]
	}
}
```
以上为服务端代码，代码定义了几个全局变量，`clients`是用于收集远程网络地址和对应连接的映射关系；`addCh`是启用一个连接管道来处理产生的所有连接；`delCh`管道负责记录销毁的远程连接的地址；`messageCh`管道用来处理聊天消息；`listenAddr`是我们服务器的地址。服务端循环监听本地，开启一个协程调用`broadcaster()`函数来处理各种情况。当有远程客户端要与服务端建立连接时，就会将产生的连接加入到addCh管道中，并且创建一个协程调用`handleConn(conn)`对该连接进行操作。`broadcaster()`会记录整个过程中发生的事件并做出相应的动作。

```go
package main

import (
	"fmt"
	"net"
	"os"
	"strings"
)

var (
	serverAddr = "localhost:8080"
)

func main() {
	conn, err := net.Dial("tcp", serverAddr)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer conn.Close()

	go func() {
		for {
			msg := make([]byte, 4096)
			n, err := conn.Read(msg)
			if err != nil {
				fmt.Println(err)
				os.Exit(1)
			}

			fmt.Println(strings.TrimSpace(string(msg[:n])))
		}
	}()

	for {
		var msg string
		fmt.Scanln(&msg)
		if msg == "/quit" {
			return
		}

		_, err := conn.Write([]byte(msg))
		if err != nil {
			fmt.Println(err)
			return
		}
	}
}

```
客户端代码中，在与服务端建立连接后，开启一个协程负责接收服务端发送来的信息，主协程再将用户从标准输入写入的信息发送给服务端，就这样客户端和服务端实现了通信。


## golang url编程
`net/url`包来进行URL编程，我们可以通过它来解析、构建和操作URL字符串。

- `url.Parse("https://.....")` 函数解析传入的url字符串，返回`url.URL`结构体和错误。`url.URL`结构体包含url的各个组成部分，如Scheme、HOST、Path、Query和Fragment等。
- 通过构建`url.URL`结构体对应的实例，来构建url。
- 要解析查询参数，可以使用`Values`类型。
- `QueryEscape(s string) string`函数对s进行转码使之可以安心的用在URL查询里。
- `QueryUnescape(s string) (string, error)`函数用于将QueryEscape转码的字符串还原。